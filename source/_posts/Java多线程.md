---
title: Java多线程与高并发
categories: Java
tags: 多线程
---
 #### 锁（synchronized，ReentrantLock......）
 多个锁都是自己本身，互相调用
 ```
public class ThreadTest {
    synchronized void test() {
        System.out.println("test....start");
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("test....end");
    }
}

class test2 extends ThreadTest {
    @Override
    // 锁的对象是this
    synchronized void test() {
        System.out.println("child test2 start");
        // 锁的对象也是this
        super.test();
        System.out.println("child test2 end");
    }
}
```
synchronized 底层：互斥锁，悲观锁，同步锁，重量级锁（jdk1.6之前）
1.悲观锁（Pessimistic Lock）： 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。
但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理
数据库中的行锁，表锁，读锁（共享锁），写锁（排他锁），以及syncronized实现的锁均为悲观锁
2.乐观锁（Optimistic Lock）： 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，但是如果想要更新数据，则会在更新前检查在读取至更新这段时间别人有没有修改过这个数据。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）,乐观锁适用于多读的应用类型，这样可以提高吞吐量
相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本（version）或者是时间戳来实现，不过使用版本记录是最常用的。
3.互斥锁加锁失败后，线程释放CPU，给其他线程；
4.自旋锁加锁失败后，线程会忙等待，直到它拿到锁；
自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。
--------------锁状态：
偏向锁 ->轻量级锁->重量级锁    锁升级
ReentrantLock 默认情况下是非公平锁
5.公平锁 
每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。
6.非公平锁
每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁
7.AQS
是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int State ）和一个先进先出（ FIFO ）的线程等待队列来实现一个多线程访问共享资源的同步框架.

 #### 异常和锁
 程序在执行过程中如果出现异常，默认情况锁会被释放，所以在并发处理的过程中，有异常要多加小心，否则会发生不一致的情况。
 #### 避免死锁  jstack查看是否死锁
 1.有序资源分配法：各个资源必须按顺序使用。
 2.银行家算法
 3.顺序加锁：多个线程需要相同的锁，但是按照不同的顺序加锁，会导致死锁，顺序加锁则会避免。
 4.限时加锁：查过时间放弃对该锁的请求。（加锁时间不能相同） synchronized不可以加时间限制，需要自定义锁。
  #### 多线程特性
 1.原子性
 2.可见性 一个线程修改了数据其他线程能够立即得到修改的值
 3.有序性
 #### CAS(Compare And Swap) 
 实现思想 CAS（V,A,B），V为内存地址、A为预期原值，B为新值。如果内存地址的值与预期原值相匹配，那么将该位置值更新为新值。否则，说明已经被其他线程更新，处理器不做任何操作；无论哪种情况，它都会在 CAS 指令之前返回该位置的值。而我们可以使用自旋锁，循环CAS，重新读取该变量再尝试再次修改该变量，也可以放弃操作。
 CAS缺点
　　CAS有几个缺点：
　　1、ABA问题。当第一个线程执行CAS操作，尚未修改为新值之前，内存中的值已经被其他线程连续修改了两次，使得变量值经历 A -> B -> A的过程。
　　解决方案：添加版本号作为标识，每次修改变量值时，对应增加版本号； 做CAS操作前需要校验版本号。JDK1.5之后，新增AtomicStampedReference类来处理这种情况。
　　2、循环时间长开销大。如果有很多个线程并发，CAS自旋可能会长时间不成功，会增大CPU的执行开销。
　　3、只能对一个变量进原子操作。JDK1.5之后，新增AtomicReference类来处理这种情况，可以将多个变量放到一个对象中。
 #### Lock
 1.ReentrantLock(可重入锁)
 2.ReadWriteLock(读写锁：可同时读，读时不可写；写时不可读，不可同时写)
 #### Volatile 关键字
 1.保证了可见性（不保证原子性）
 2.禁止进行指令重排序（保证有序性）
 3.对变量的写操作不依赖于当前的值和该变量没有与其他变量一起使用时应用该关键字